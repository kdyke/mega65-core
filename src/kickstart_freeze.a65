freeze_to_slot:
	; Freeze current running process to the specified slot

	; Slot in XXYY

	jsr syspart_locate_freezeslot
	bcc ffail
	jmp freeze_save_to_sdcard_immediate
ffail:	rts


freeze_save_to_sdcard_immediate:

	; Save the current process to the SD card. $D681-4 are expecxted to
	; already be pointing to the first sector of the freeze slot

	; Stash SD card registers to scratch area
	jsr do_freeze_prep_sdcard_regs_to_scratch

	; Save current SD card sector buffer contents
	jsr freeze_write_sector_and_wait

	; Save each region in the list
	ldx #$00
freeze_next_region:
	jsr freeze_save_region
	txa
	clc
	adc #$08
	tax
	lda freeze_mem_list+7,x
	cmp #$ff
	bne freeze_next_region

	rts

unfreeze_load_from_sdcard_immediate:

	; Save the current process to the SD card. $D681-4 are expecxted to
	; already be pointing to the first sector of the freeze slot

	; Stash SD card registers to scratch area
	jsr do_freeze_prep_sdcard_regs_to_scratch

	; Save each region in the list
	ldx #$00
unfreeze_next_region:
	jsr unfreeze_load_region
	txa
	clc
	adc #$08
	tax
	lda freeze_mem_list+7,x
	cmp #$ff
	bne unfreeze_next_region

	rts

unfreeze_read_sector_and_wait:

	; Require SHIFT press and release between every sector
;ufrw1:	lda $d611
;	beq ufrw1
;ufrw2:	lda $d611
;	bne ufrw2

@retryRead:
	jsr sd_wait_for_ready_reset_if_required	
	lda #$02
	sta $d680
	jsr sd_wait_for_ready
	bcc @retryRead

	; Read succeeded, so advance sector number, and return
	; success

	; Increment freeze slot sector number
	jsr sd_inc_fixedsectornumber

	sec

	rts

freeze_write_sector_and_wait:

	lda $d681
	lda $d682
	lda $d683
	lda $d684

	; Require SHIFT press and release between every sector
;fww1:	lda $d611
;	beq fww1
;fww2:	lda $d611
;	bne fww2


	lda #$00
	sta freeze_write_tries+0
	sta freeze_write_tries+1

	lda $d681
	pha
	lda $d682
	pha
	lda $d683
	pha
	lda $d684
	pha

@retryWrite:
	jsr sd_wait_for_ready_reset_if_required
	; Trigger the write
	lda #$03
	sta $d680
	jsr sd_wait_for_ready
	bcs @wroteOk

	inc freeze_write_tries+0
	bne @retryWrite
	inc freeze_write_tries+1
	bne @retryWrite

@wroteOk:

	pla
	sta $d684
	pla
	sta $d683
	pla
	sta $d682
	pla
	sta $d681

	; Increment freeze slot sector number
	jsr sd_inc_fixedsectornumber

	sec
	rts

freeze_write_tries:
	.word $0

freeze_save_region:
	; X = offset into freeze_mem_list

	; Check if end of list, if so, do nothing and return
	lda freeze_mem_list+7,x
	cmp #$ff
	bne fsr1
	rts
fsr1:

	; Call setup routine to make any special preparations
	; (eg copying data out of non-memory mapped areas, or collecting
	; various groups of data together)
	phx
	tax
	jsr	dispatch_freeze_prep
	plx

	; Get address of region
	lda freeze_mem_list+0,x
	sta freeze_region_dmalist_source_start+0
	lda freeze_mem_list+1,x
	sta freeze_region_dmalist_source_start+1

	; Source address is 32-bit, and we need bits 20-27
	; for the source MB (upper 4 bits are ignored)
	lda freeze_mem_list+2,x
	lsr
	lsr
	lsr
	lsr
	sta freeze_region_dmalist_source_mb
	lda freeze_mem_list+3,x
	asl
	asl
	asl
	asl
	ora freeze_region_dmalist_source_mb
	sta freeze_region_dmalist_source_mb

	; Bank is a bit fiddly: Lower nybl is bits
	; 16-19 of address.  Then we have to add the IO flag
	; The IO flag is used if the source MB value = $FF.
	; However, because we use 28-bit addresses for everything
	; the IO bit should be zero, as should the other special
	; bits.

	lda freeze_mem_list+2,X
	and #$0f
	sta freeze_region_dmalist_source_bank

	; At this point, we have the DMA list source setup.

	; Point the destination to the SD card direct job
	; sector buffer ($FFD6E00).
	lda #$00
	sta freeze_region_dmalist_dest_start+0
	lda #$6E
	sta freeze_region_dmalist_dest_start+1
	lda #$0D
	sta freeze_region_dmalist_dest_bank
	lda #$ff
	sta freeze_region_dmalist_dest_mb

	; Now DMA source and destination addresses have been set
	; We now need to step through the region $200 bytes at a
	; time, until there are no bytes left.
	; If the length is $0000 initially, then it means 64KB.
	; The tricky bit is for regions <$200 bytes long, as we need
	; to make sure we don't copy more than we should (it could
	; be from Hypervisor memory, for example, or to some
	; important IO registers, such as the Hypervisor enter/exit
	; trap).

	; Get length of region
	lda freeze_mem_list+4,x
	sta freeze_dma_length_remaining+0
	lda freeze_mem_list+5,x
	sta freeze_dma_length_remaining+1	
	lda freeze_mem_list+6,x
	sta freeze_dma_length_remaining+2

freeze_region_dma_loop:

	lda freeze_dma_length_remaining
	lda freeze_dma_length_remaining+1
	lda freeze_dma_length_remaining+2

	; Check if remaining length is negative or zero. If so, stop
	lda freeze_dma_length_remaining+2
	bmi freeze_region_dma_done
	ora freeze_dma_length_remaining+1
	ora freeze_dma_length_remaining+0
	beq freeze_region_dma_done

	lda freeze_dma_length_remaining+0
	sta freeze_region_dmalist_count+0
	ora freeze_dma_length_remaining+1
	beq @multipleOf64KRemaining
	lda freeze_dma_length_remaining+1
	sta freeze_region_dmalist_count+1
	cmp #$02
	bcc not_too_big
@multipleOf64KRemaining:
	; remaining length too great, or
	; bottom 16 bits = 0, i.e., multiple of 64KB remaining
	lda #$02
	sta freeze_region_dmalist_count+1
not_too_big:
	; DMA count is set, subtract from remaining length
	sec
	lda freeze_dma_length_remaining+0
	sbc freeze_region_dmalist_count+0
	sta freeze_dma_length_remaining+0
	lda freeze_dma_length_remaining+1
	sbc freeze_region_dmalist_count+1
	sta freeze_dma_length_remaining+1
	lda freeze_dma_length_remaining+2
	sbc #$00
	sta freeze_dma_length_remaining+2

	lda freeze_region_dmalist_count+0
	lda freeze_region_dmalist_count+1

	; advance source address
	lda freeze_region_dmalist_source_start+1
	clc
	adc #$02
	sta freeze_region_dmalist_source_start+1
	lda freeze_region_dmalist_source_bank
	adc #$00
	sta freeze_region_dmalist_source_bank
	

	; Execute DMA job
	lda #$ff
	sta $d702
	sta $d704
	lda #>freeze_region_dmalist
	sta $d701
	lda #<freeze_region_dmalist
	sta $d705		

	; Write SD-card direct sector buffer to freeze slot
	; Flash a different colour while actually writing sector
	inc $d020

	jsr freeze_write_sector_and_wait

	dec $d020

	jmp freeze_region_dma_loop

freeze_region_dma_done:

	; And increase screen colour after writing each region
;	inc $d020

	rts

unfreeze_load_region:
	; X = offset into freeze_mem_list

	; Check if end of list, if so, do nothing and return
	lda freeze_mem_list+7,x
	cmp #$ff
	bne ufsr1
	rts
ufsr1:

	; Call setup routine to make any special preparations
	; (eg copying data out of non-memory mapped areas, or collecting
	; various groups of data together)
	phx
	tax
	jsr	dispatch_unfreeze_prep
	plx

	; Get address of region
	lda freeze_mem_list+0,x
	sta freeze_region_dmalist_dest_start+0
	lda freeze_mem_list+1,x
	sta freeze_region_dmalist_dest_start+1

	; Source address is 32-bit, and we need bits 20-27
	; for the source MB (upper 4 bits are ignored)
	lda freeze_mem_list+2,x
	lsr
	lsr
	lsr
	lsr
	sta freeze_region_dmalist_dest_mb
	lda freeze_mem_list+3,x
	asl
	asl
	asl
	asl
	ora freeze_region_dmalist_dest_mb
	sta freeze_region_dmalist_dest_mb

	; Bank is a bit fiddly: Lower nybl is bits
	; 16-19 of address.  Then we have to add the IO flag
	; The IO flag is used if the source MB value = $FF.
	; However, because we use 28-bit addresses for everything
	; the IO bit should be zero, as should the other special
	; bits.

	lda freeze_mem_list+2,X
	and #$0f
	sta freeze_region_dmalist_dest_bank

	; At this point, we have the DMA list source setup.

	; Point the source to the SD card direct job
	; sector buffer ($FFD6E00).
	lda #$00
	sta freeze_region_dmalist_source_start+0
	lda #$6E
	sta freeze_region_dmalist_source_start+1
	lda #$0D
	sta freeze_region_dmalist_source_bank
	lda #$ff
	sta freeze_region_dmalist_source_mb

	; Now DMA source and destination addresses have been set
	; We now need to step through the region $200 bytes at a
	; time, until there are no bytes left.
	; If the length is $0000 initially, then it means 64KB.
	; The tricky bit is for regions <$200 bytes long, as we need
	; to make sure we don't copy more than we should (it could
	; be from Hypervisor memory, for example, or to some
	; important IO registers, such as the Hypervisor enter/exit
	; trap).

	; Get length of region
	lda freeze_mem_list+4,x
	sta freeze_dma_length_remaining+0
	lda freeze_mem_list+5,x
	sta freeze_dma_length_remaining+1	
	lda freeze_mem_list+6,x
	sta freeze_dma_length_remaining+2

unfreeze_region_dma_loop:

	; Write SD-card direct sector buffer to freeze slot
	; Flash a different colour while actually writing sector
	inc $d020

	jsr unfreeze_read_sector_and_wait

	dec $d020

	lda freeze_dma_length_remaining
	lda freeze_dma_length_remaining+1
	lda freeze_dma_length_remaining+2

	; Check if remaining length is negative or zero. If so, stop
	lda freeze_dma_length_remaining+2
	bmi unfreeze_region_dma_done
	ora freeze_dma_length_remaining+1
	ora freeze_dma_length_remaining+0
	beq unfreeze_region_dma_done

	lda freeze_dma_length_remaining+0
	sta freeze_region_dmalist_count+0
	ora freeze_dma_length_remaining+1
	beq @multipleOf64KRemainingUnfreeze
	lda freeze_dma_length_remaining+1
	sta freeze_region_dmalist_count+1
	cmp #$02
	bcc not_too_big_unfreeze
@multipleOf64KRemainingUnfreeze:
	; remaining length too great, or
	; bottom 16 bits = 0, i.e., multiple of 64KB remaining
	lda #$02
	sta freeze_region_dmalist_count+1
not_too_big_unfreeze:
	; DMA count is set, subtract from remaining length
	sec
	lda freeze_dma_length_remaining+0
	sbc freeze_region_dmalist_count+0
	sta freeze_dma_length_remaining+0
	lda freeze_dma_length_remaining+1
	sbc freeze_region_dmalist_count+1
	sta freeze_dma_length_remaining+1
	lda freeze_dma_length_remaining+2
	sbc #$00
	sta freeze_dma_length_remaining+2

	lda freeze_region_dmalist_count+0
	lda freeze_region_dmalist_count+1

	; advance source address
	lda freeze_region_dmalist_source_start+1
	clc
	adc #$02
	sta freeze_region_dmalist_source_start+1
	lda freeze_region_dmalist_source_bank
	adc #$00
	sta freeze_region_dmalist_source_bank
	

	; Execute DMA job
	lda #$ff
	sta $d702
	sta $d704
	lda #>freeze_region_dmalist
	sta $d701
	lda #<freeze_region_dmalist
	sta $d705		

	jmp unfreeze_region_dma_loop

unfreeze_region_dma_done:

	; Call postfix routine for the region just loaded
	phx
	tax
	jsr	dispatch_unfreeze_post
	plx

	; And increase screen colour after reading each region
;	inc $d020


	rts


dispatch_freeze_prep:
	; X = Freeze prep ID byte
	; (all of which are even, so that we can use an indirect
	; X indexed jump table to efficiently do the dispatch)

	jmp (freeze_prep_jump_table,x)

dispatch_unfreeze_prep:
	; X = Freeze prep ID byte
	; (all of which are even, so that we can use an indirect
	; X indexed jump table to efficiently do the dispatch)

	jmp (unfreeze_prep_jump_table,x)

dispatch_unfreeze_post:
	; X = Freeze prep ID byte
	; (all of which are even, so that we can use an indirect
	; X indexed jump table to efficiently do the dispatch)

	jmp (unfreeze_post_jump_table,x)


do_unfreeze_post_restore_sd_buffer_and_regs:
	; XXX - Not implemented, should reverse the following
do_unfreeze_prep_restore_sd_buffer_and_regs:
	; But there is nothing we need to do in preparation to unfreezing
	; such a region, so just tie it to an RTS
	RTS

do_freeze_prep_stash_sd_buffer_and_regs:
	; Stash the SD and DMAgic registers we use to actually save
	; the machine state.
	; DMAgic registers have to get copied without using DMA, so
	; that we don't corrupt the registers.
	LDA    #<$6200
	STA    dos_scratch_vector+0
	LDA    #>$6200
	STA    dos_scratch_vector+1
	LDA    #<$0FFD
	STA    dos_scratch_vector+2
	LDA    #>$0FFD
	STA    dos_scratch_vector+3
	
	LDZ    #$8F
@zz:	TZA
	TAX
	LDA    $D680,X
	NOP
	NOP
	STA	(<dos_scratch_vector) ,Z
	DEX
	DEZ
	CPZ #$FF
	BNE	@zz
	LDZ	#$00

	; Now DMA copy the SD sector buffer from $FFD6e00 to
	; $FFD6000.
	; XXX Replace this (And the above!) with a fixed DMA list. It will be shorter and faster
	lda	#$ff
	sta	freeze_region_dmalist_source_mb
	sta	freeze_region_dmalist_dest_mb
	lda	#$8d
	sta	freeze_region_dmalist_source_bank
	sta	freeze_region_dmalist_dest_bank
	lda	#<$6e00
	sta	freeze_region_dmalist_source_start+0
	lda	#>$6e00
	sta	freeze_region_dmalist_source_start+1
	lda	#<$6000
	sta	freeze_region_dmalist_dest_start+0
	lda	#>$6000
	sta	freeze_region_dmalist_dest_start+1
	lda	#<$0200
	sta	freeze_region_dmalist_count+0
	lda	#>$0200
	sta	freeze_region_dmalist_count+1

	; Execute DMA job
	lda #$ff
	sta $d702
	sta $d704
	lda #>freeze_region_dmalist
	sta $d701
	lda #<freeze_region_dmalist
	sta $d705

	rts

; Jump table of routines to be called before saving specific regions
freeze_prep_jump_table:
	.alias freeze_prep_none 0
	.word do_freeze_prep_sdcard_regs_to_scratch
	.alias freeze_prep_palette0 2
	.alias freeze_prep_palette1 4
	.alias freeze_prep_palette2 6
	.alias freeze_prep_palette3 8
	.word do_freeze_prep_palette_select
	.word do_freeze_prep_palette_select
	.word do_freeze_prep_palette_select
	.word do_freeze_prep_palette_select
	.alias freeze_prep_stash_sd_buffer_and_regs 10
	.word do_freeze_prep_stash_sd_buffer_and_regs

; Jump table of routines to be called before restoring specific regions
; (the same region list is used for freeze and unfreeze, so the jump
; tables for unfreezing mirror those used during freezing. The only difference
; is we require two sets of jump tables for unfreezing, as sometimes we have
; to prepare the memory map before restoring, and sometimes we have to move
; the restored data to the correct place in memory after restoration.
unfreeze_prep_jump_table:
	; SD card buffer and regs get restored in post routine
	.word do_unfreeze_prep_none
	.word do_unfreeze_prep_palette_select
	.word do_unfreeze_prep_palette_select
	.word do_unfreeze_prep_palette_select
	.word do_unfreeze_prep_palette_select
	; SD card buffer and regs get restored in post routine
	.word do_unfreeze_prep_none

unfreeze_post_jump_table:
	.word do_unfreeze_post_scratch_to_sdcard_regs
	.word do_unfreeze_post_none
	.word do_unfreeze_post_none
	.word do_unfreeze_post_none
	.word do_unfreeze_post_none
	.word do_unfreeze_post_restore_sd_buffer_and_regs	

do_unfreeze_prep_none:
do_unfreeze_post_none:
	; This just needs to have an RTS, so we use one from the end of this
	; routine.
	RTS

do_unfreeze_post_scratch_to_sdcard_regs:
	; XXX - Not implemented
	RTS

do_freeze_prep_sdcard_regs_to_scratch:
	; Copy the main SD card access registers to a
	; scratch area, so that we can save them, and thus restore
	; them after unfreezing.
	; (This is done outside of the automatic loop, because
	; it has to be handled specially.)
	ldx #$0f
dfp1:	lda $d680,x
	sta freeze_scratch_area,x
	dex
	bpl dfp1
	rts

freeze_scratch_area:
	.byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

freeze_region_dmalist:
	.byte $0A ; F011A format DMA list
	.byte $80 ; Source MB option follows
freeze_region_dmalist_source_mb:
	.byte $00
	.byte $81 ; Dest MB option follows
freeze_region_dmalist_dest_mb:
	.byte $00
	.byte $00 ; end of enhanced DMA option list

	; F011A format DMA list
	.byte $00 ; copy + last request in chain
freeze_region_dmalist_count:
	.word $0000 ; size of copy
freeze_region_dmalist_source_start:
	.word $0000 ; source address lower 16 bits
freeze_region_dmalist_source_bank:
	.byte $00   ;
freeze_region_dmalist_dest_start:
	.word $0000
freeze_region_dmalist_dest_bank:
	.byte $00
	.word $0000 ; modulo (unused)	

do_unfreeze_prep_palette_select:
	; We do the same memory map setup during freeze and unfreeze
do_freeze_prep_palette_select:
	; X = 6, 8, 10 or 12
	; Use this to pick which of the four palette banks
	; is visible at $D100-$D3FF
	txa
	clc
	sbc #freeze_prep_palette0
	asl
	asl
	asl
	asl
	asl
	ora #$3f  ; keep displaying the default palette
	sta $d070
	rts
	





freeze_mem_list:
	; start address (4 bytes), length (3 bytes),
	; preparatory action required before reading/writing (1 byte)
	; Each segment will live in its own sector (or sectors if
	; >512 bytes) when frozen. So we should avoid excessive
	; numbers of blocks.

	; core SDcard registers we need to be ready to start writing
	; sectors. We copy these out and in manually at the start
	; and end of the freeze and unfreeze routines, respectively.
	; So they are not done here
	;	.dword freezer_scratch_area
	;       .byte 0
	;	.word $0010
	;	.byte freeze_prep_none

	; SDcard sector buffer + SD card registers
	; We have to save this before anything much else, because
	; we need it for freezing.  We stash $FFD6E00-FFF and
	; $FFD3680-70F at $FFD6000 before hand, so that we preserve
	; these registers before touching them.
	; (the DMAgic registers at $DDF370x have to get copied manually,
	; so that we don't mess up the DMA state.  Also, when restoring
	; we have to take some care putting them back exactly.)
	.dword $ffd6000
	.word $0290
	.byte 0
	.byte freeze_prep_stash_sd_buffer_and_regs

	; SDcard sector buffer (F011)
	.dword $ffd6c00
	.word $0200
	.byte 0
	.byte freeze_prep_none

	; VIC-IV palette block 0
	.dword $ffd3100
	.word $0300
	.byte 0
	.byte freeze_prep_palette0

	; VIC-IV palette block 1
	.dword $ffd3100
	.word $0300
	.byte 0
	.byte freeze_prep_palette1

	; VIC-IV palette block 2
	.dword $ffd3100
	.word $0300
	.byte 0
	.byte freeze_prep_palette2

	; VIC-IV palette block 3
	.dword $ffd3100
	.word $0300
	.byte 0
	.byte freeze_prep_palette3	

	; Process scratch space
	.dword currenttask_block
	.word $0100
	.byte 0
	.byte freeze_prep_none
	
	; $D640-$D67E hypervisor state registers
	; XXX - These can't be read by DMA, so we need to have a
	; prep routine that copies them out first?
	.dword $ffd3640
	.word $003F
	.byte 0
	.byte freeze_prep_none

	; VIC-IV, F011 $D000-$D0FF
	.dword $ffd3000
	.word $0100
	.byte 0
	.byte freeze_prep_none

	; XXX - Other IO chips!

	; 128KB RAM + 128KB "ROM"
	.dword $0000000
	.word $0000      
	.byte 4          ; =4x64K blocks = 128K + 128K
	.byte freeze_prep_none	

	; $D700-$D7FF CPU registers
	.dword $ffd3700
	.word $0100
	.byte 0
	.byte freeze_prep_none
	
	; 32KB colour RAM
	.dword $ff80000
	.word $8000
	.byte $00
	.byte freeze_prep_none

	; End of list
	.dword $FFFFFFFF
	.word $FFFF
	.byte $FF
	.byte $FF

freeze_dma_length_remaining:
	.byte 0,0,0

